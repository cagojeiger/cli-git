# 함수형 프로그래밍 실전 가이드

## 개요

함수형 프로그래밍(FP)은 부작용을 최소화하고 순수 함수를 중심으로 프로그램을 구성하는 패러다임입니다. Python과 CLI 애플리케이션 컨텍스트에서 실용적으로 적용하는 방법을 다룹니다.

## 핵심 개념

### 1. 순수 함수 (Pure Functions)

순수 함수는 다음 두 가지 특성을 만족합니다:
- **결정적(Deterministic)**: 같은 입력에 대해 항상 같은 출력
- **부작용 없음(No Side Effects)**: 외부 상태를 변경하지 않음

```python
# ❌ 순수하지 않은 함수
total = 0
def add_to_total(value):
    global total
    total += value  # 외부 상태 변경
    return total

# ✅ 순수 함수
def add(a, b):
    return a + b  # 외부 상태에 의존하지 않음
```

### 2. 부작용 (Side Effects)

부작용은 함수가 자신의 스코프 밖에 영향을 미치는 모든 것:
- 파일 I/O
- 네트워크 요청
- 데이터베이스 작업
- 콘솔 출력
- 전역 상태 변경
- 예외 발생 (프로그램 흐름 변경)

## 실전 패턴: 순수 함수 핵심과 명령형 셸

가장 실용적인 함수형 프로그래밍 패턴은 애플리케이션을 두 부분으로 나누는 것입니다:

```python
# 1. 순수 함수 핵심 (Pure Functional Core)
def calculate_mirror_config(repo_data: dict) -> dict:
    """순수 함수: 데이터 변환만 수행"""
    return {
        "name": repo_data.get("fullName", ""),
        "is_private": repo_data.get("isPrivate", False),
        "mirror_url": f"https://github.com/{repo_data.get('fullName', '')}",
    }

def validate_mirror_data(mirror_data: dict) -> tuple[bool, str]:
    """순수 함수: 검증 로직"""
    if not mirror_data.get("name"):
        return False, "Repository name is required"
    if not mirror_data.get("mirror_url"):
        return False, "Mirror URL is required"
    return True, ""

# 2. 명령형 셸 (Imperative Shell)
def setup_mirror_command(repo_name: str) -> None:
    """명령형 셸: I/O와 부작용 처리"""
    # I/O: API 호출
    repo_data = fetch_repo_data(repo_name)

    # 순수 함수 호출
    mirror_config = calculate_mirror_config(repo_data)
    is_valid, error_msg = validate_mirror_data(mirror_config)

    # I/O: 결과 출력
    if not is_valid:
        typer.echo(f"❌ {error_msg}")
        raise typer.Exit(1)

    # I/O: 파일 시스템 작업
    save_mirror_config(mirror_config)
    typer.echo("✅ Mirror configured successfully")
```

## CLI 애플리케이션에서의 함수형 프로그래밍

### 1. Typer와 부작용 관리

Typer CLI에서 `typer.Exit()`는 정상적인 프로그램 종료 메커니즘입니다:

```python
# ❌ 부작용을 숨기는 안티패턴
def process_and_display(data):
    result = process_data(data)
    display_result(result)  # 내부에서 typer.Exit() 호출
    return result  # 도달 불가능한 코드!

# ✅ 명시적 제어 흐름
def process_command(data):
    # 순수 함수로 처리
    result = process_data(data)
    formatted = format_result(result)

    # 명시적 I/O와 종료
    typer.echo(formatted)
    if result.get("exit_required"):
        raise typer.Exit(0)
```

### 2. 설정과 상태 관리

```python
# ❌ 전역 상태에 의존
config = load_config()

def get_mirror_url():
    return config["mirror_url"]  # 외부 상태에 의존

# ✅ 의존성 주입
def get_mirror_url(config: dict) -> str:
    return config["mirror_url"]  # 파라미터로 전달받음

# 사용 예
def main_command():
    config = load_config()  # 진입점에서 로드
    url = get_mirror_url(config)  # 명시적 전달
```

### 3. 에러 처리

```python
# ❌ 예외를 통한 제어 흐름
def validate_url(url: str) -> str:
    if not url.startswith("https://"):
        raise ValueError("URL must use HTTPS")
    return url

# ✅ Result 타입 패턴
from typing import Union, Tuple

def validate_url(url: str) -> Tuple[bool, Union[str, None]]:
    if not url.startswith("https://"):
        return False, "URL must use HTTPS"
    return True, None

# 사용
is_valid, error = validate_url(url)
if not is_valid:
    typer.echo(f"❌ {error}")
    raise typer.Exit(1)
```

## 실전 리팩토링 예시

### Before: 혼재된 관심사

```python
def update_mirrors(repo_list: list[str], verbose: bool):
    """모든 것이 뒤섞인 함수"""
    successful = []
    failed = []

    for repo in repo_list:
        try:
            # API 호출 (I/O)
            response = requests.get(f"https://api.github.com/repos/{repo}")
            data = response.json()

            # 비즈니스 로직
            if data.get("private") and not data.get("permissions", {}).get("admin"):
                failed.append(repo)
                if verbose:
                    print(f"Skipping {repo}: No admin access")
                continue

            # 더 많은 I/O
            subprocess.run(["git", "clone", data["clone_url"]])

            # 상태 업데이트
            successful.append(repo)

            # 출력
            if verbose:
                print(f"✓ Updated {repo}")

        except Exception as e:
            failed.append(repo)
            if verbose:
                print(f"✗ Failed {repo}: {e}")

    # 최종 출력
    print(f"\nSuccess: {len(successful)}, Failed: {len(failed)}")
```

### After: 분리된 관심사

```python
# 순수 함수들
def can_update_mirror(repo_data: dict) -> Tuple[bool, str]:
    """순수 함수: 업데이트 가능 여부 판단"""
    if repo_data.get("private") and not repo_data.get("permissions", {}).get("admin"):
        return False, "No admin access to private repository"
    return True, ""

def categorize_results(
    repos: list[str],
    results: list[Tuple[str, bool, str]]
) -> dict:
    """순수 함수: 결과 분류"""
    successful = [r[0] for r in results if r[1]]
    failed = [(r[0], r[2]) for r in results if not r[1]]

    return {
        "successful": successful,
        "failed": failed,
        "summary": {
            "total": len(repos),
            "success_count": len(successful),
            "fail_count": len(failed)
        }
    }

def format_results(results: dict, verbose: bool) -> list[str]:
    """순수 함수: 결과 포맷팅"""
    lines = []

    if verbose:
        for repo in results["successful"]:
            lines.append(f"✓ Updated {repo}")
        for repo, reason in results["failed"]:
            lines.append(f"✗ Failed {repo}: {reason}")
        lines.append("")

    lines.append(
        f"Success: {results['summary']['success_count']}, "
        f"Failed: {results['summary']['fail_count']}"
    )

    return lines

# 명령형 셸
def update_mirrors_command(repo_list: list[str], verbose: bool):
    """명령형 셸: I/O 조정"""
    results = []

    for repo in repo_list:
        # I/O: API 호출
        repo_data = fetch_repo_data(repo)

        # 순수 함수 호출
        can_update, reason = can_update_mirror(repo_data)

        if can_update:
            # I/O: Git 작업
            success = perform_git_update(repo_data["clone_url"])
            results.append((repo, success, "" if success else "Git operation failed"))
        else:
            results.append((repo, False, reason))

    # 순수 함수로 결과 처리
    categorized = categorize_results(repo_list, results)
    output_lines = format_results(categorized, verbose)

    # I/O: 출력
    for line in output_lines:
        typer.echo(line)
```

## 함수 합성과 파이프라인

```python
from functools import reduce
from typing import Callable, TypeVar

T = TypeVar('T')

def pipe(*functions: Callable) -> Callable:
    """함수들을 연결하여 파이프라인 생성"""
    def pipeline(value):
        return reduce(lambda v, f: f(v), functions, value)
    return pipeline

# 사용 예
process_mirror = pipe(
    fetch_repo_data,           # IO
    validate_repo_data,        # Pure
    calculate_mirror_config,   # Pure
    validate_mirror_config,    # Pure
    save_mirror_config,        # IO
)

# 에러 처리가 필요한 경우
from typing import Either  # 타입 힌트용

def safe_pipe(*functions):
    """에러를 전파하는 파이프라인"""
    def pipeline(value):
        for func in functions:
            if isinstance(value, Error):
                return value
            value = func(value)
        return value
    return pipeline
```

## 테스트 가능성

함수형 접근의 가장 큰 장점은 테스트 용이성입니다:

```python
# 순수 함수는 테스트가 간단
def test_calculate_mirror_config():
    repo_data = {
        "fullName": "user/repo",
        "isPrivate": True
    }

    result = calculate_mirror_config(repo_data)

    assert result == {
        "name": "user/repo",
        "is_private": True,
        "mirror_url": "https://github.com/user/repo"
    }

# I/O가 분리되어 있으면 목(mock) 최소화
def test_update_mirrors_command(mock_fetch, mock_git):
    mock_fetch.return_value = {"fullName": "user/repo", "clone_url": "..."}
    mock_git.return_value = True

    # 핵심 로직은 순수 함수로 이미 테스트됨
    # 여기서는 통합만 검증
    update_mirrors_command(["user/repo"], verbose=False)
```

## 실용적 조언

1. **완벽한 함수형을 추구하지 마라**: Python은 멀티패러다임 언어입니다.
2. **부작용을 최소화하되 제거에 집착하지 마라**: CLI는 본질적으로 I/O 중심입니다.
3. **테스트 가능성을 기준으로 판단하라**: 테스트하기 어렵다면 리팩토링이 필요한 신호입니다.
4. **점진적으로 적용하라**: 한 번에 모든 것을 바꾸려 하지 마세요.

## 결론

함수형 프로그래밍은 더 나은 코드를 작성하기 위한 도구입니다. 교조적으로 적용하기보다는, 코드의 가독성, 유지보수성, 테스트 가능성을 높이는 방향으로 실용적으로 활용해야 합니다.

> "Make it work, make it right, make it fast" - Kent Beck

순수 함수와 부작용의 분리는 "make it right" 단계에서 강력한 도구가 됩니다.
