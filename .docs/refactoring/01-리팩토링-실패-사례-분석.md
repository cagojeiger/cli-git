# 리팩토링 실패 사례 분석

## 개요

이 문서는 `cli-git` 프로젝트에서 발생한 리팩토링 실패 사례를 분석하고, 그로부터 얻은 교훈을 정리합니다. 이 사례는 "좋은 의도"가 항상 "좋은 결과"로 이어지지 않음을 보여주는 대표적인 예시입니다.

## 실패한 리팩토링 개요

### 초기 상황
- `private_mirror.py`: 428줄
- `update_mirrors.py`: 405줄
- CLAUDE.md 원칙: 500줄을 초과하는 파일은 리팩토링 필요
- 함수형 프로그래밍 패러다임 채택

### 시도한 해결책
큰 파일들을 작은 모듈로 기계적으로 분리:
```
commands/
├── private_mirror.py (428줄 → 51줄)
├── mirror/
│   ├── __init__.py
│   ├── mirror_workflow.py
│   ├── config.py
│   └── operations.py
└── update/
    ├── __init__.py
    ├── update_validation.py
    └── update_operations.py
```

### 결과
- ✅ 파일 크기는 줄어듦
- ✅ 테스트 커버리지 88.86% 달성
- ❌ 5개의 테스트 실패
- ❌ 함수형 프로그래밍 원칙 위반
- ❌ CI 파이프라인 실패

## 근본 원인 분석

### 1. 기계적 분리의 함정

**잘못된 접근:**
```python
# 단순히 함수를 다른 파일로 이동
# update_validation.py
def display_scan_results(mirrors: list) -> None:
    """Display scan results in a formatted way."""
    # ... 출력 로직 ...
    raise typer.Exit(0)  # 숨겨진 부작용!
```

**문제점:**
- 함수 이름(`display_scan_results`)은 단순 출력을 암시
- 실제로는 프로그램을 종료시키는 부작용 포함
- 함수의 책임이 불명확

### 2. 일관성 없는 동작

```python
def handle_scan_option(..., verbose: bool) -> None:
    if verbose:
        display_scan_results(mirrors)  # Exit 발생
    else:
        for mirror in mirrors:
            typer.echo(mirror.get("name", ""))
        # Exit 없음 - 동작 불일치!
```

**문제점:**
- 같은 함수가 파라미터에 따라 다른 제어 흐름
- 테스트 예측 불가능
- 함수형 프로그래밍의 "동일 입력, 동일 출력" 원칙 위반

### 3. 테스트 설계와 실제 구현의 불일치

```python
# 테스트의 기대
def test_handle_scan_with_cache_verbose(self, mock_display, mock_scan):
    with pytest.raises(typer.Exit) as exc_info:
        handle_scan_option(...)  # handle_scan_option이 Exit를 발생시킬 것으로 예상

    assert exc_info.value.exit_code == 0

# 실제 동작
# handle_scan_option은 Exit를 발생시키지 않음
# display_scan_results가 Exit를 발생시킴
```

## 교훈

### 1. 응집도(Cohesion) 우선

**Bad:**
```python
# 관련 없는 함수들을 단순히 크기 때문에 분리
# mirror/operations.py
def clean_github_directory(...)  # Git 작업
def setup_mirror_sync(...)        # 워크플로우 설정
def validate_upstream_url(...)    # URL 검증
```

**Good:**
```python
# 의미 있는 단위로 분리
# mirror/git_operations.py
def clone_repository(...)
def setup_remotes(...)
def push_to_mirror(...)

# mirror/workflow_setup.py
def create_workflow_file(...)
def setup_mirror_sync(...)
```

### 2. 명시적 부작용 관리

**Bad:**
```python
def process_data(data):
    result = transform(data)
    save_to_database(result)  # 숨겨진 부작용
    return result
```

**Good:**
```python
# 순수 함수
def transform_data(data):
    return transform(data)

# 부작용 명시
def process_and_save(data):
    result = transform_data(data)
    save_to_database(result)
    return result
```

### 3. 점진적 리팩토링

**실패한 접근:**
1. 한 번에 전체 파일 구조 변경
2. 모든 함수를 동시에 이동
3. 테스트 실패 후 원인 파악 어려움

**올바른 접근:**
1. 하나의 순수 함수 추출
2. 테스트 실행 및 통과 확인
3. 커밋
4. 다음 함수 추출
5. 반복

### 4. 테스트가 알려주는 설계 의도

테스트가 실패한다는 것은 우리가 기존 동작을 제대로 이해하지 못했다는 신호입니다:

```python
# 테스트는 설계 문서다
def test_handle_scan_option_exits_with_verbose():
    """verbose 모드에서는 결과 표시 후 종료해야 함"""
    # 이 테스트는 handle_scan_option의 의도된 동작을 명시
```

### 5. 도메인 컨텍스트 이해

CLI 애플리케이션의 특성:
- 각 명령은 명확한 시작과 끝이 있음
- `typer.Exit()`는 정상 종료 메커니즘
- 이를 "부작용"이라고 무조건 제거하면 안 됨

## 결론

이번 리팩토링 실패는 다음을 명확히 보여줍니다:

1. **"Clean Code"는 컨텍스트를 고려해야 함** - 무조건적인 원칙 적용은 위험
2. **테스트는 거짓말하지 않음** - 테스트 실패는 우리의 이해 부족을 나타냄
3. **점진적 개선이 혁명적 변화보다 안전** - 작은 단계로 진행하며 각 단계를 검증
4. **함수형 프로그래밍은 도구이지 목적이 아님** - 상황에 맞게 적용

> "좋은 리팩토링은 코드를 읽는 사람이 변경을 느끼지 못하는 리팩토링이다"

이 원칙을 잊지 말고, 다음 리팩토링에서는 더 신중하고 점진적인 접근을 시도해야 합니다.
