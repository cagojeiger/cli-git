# 오캄의 면도날 원칙

## 개요

"Entities should not be multiplied without necessity" - William of Ockham (14세기)

오캄의 면도날은 불필요한 복잡성을 제거하라는 원칙입니다. 소프트웨어 공학에서는 "가장 단순한 해결책이 대개 최선"이라는 의미로 해석됩니다. 하지만 주의할 점은 "단순함"과 "단순주의"는 다르다는 것입니다.

## 소프트웨어에서의 오캄의 면도날

### 1. 진정한 단순함이란?

```python
# ❌ 단순주의: 모든 것을 하나로
def process_data(data, operation, format, output_type, validate, transform, save):
    """너무 많은 책임을 가진 '단순한' 함수"""
    if operation == "clean":
        # 100줄의 청소 로직
        pass
    elif operation == "analyze":
        # 200줄의 분석 로직
        pass
    # ... 더 많은 조건문

# ✅ 진정한 단순함: 명확한 책임 분리
class DataProcessor:
    def clean(self, data: Data) -> CleanedData:
        """데이터 정제만 담당"""
        return self.cleaner.clean(data)

    def analyze(self, data: CleanedData) -> Analysis:
        """분석만 담당"""
        return self.analyzer.analyze(data)
```

### 2. KISS 원칙과의 차이

- **오캄의 면도날**: 불필요한 가정이나 개체를 추가하지 마라 (철학적/전략적)
- **KISS (Keep It Simple, Stupid)**: 디자인을 단순하게 유지하라 (실용적/전술적)

```python
# 오캄의 면도날 적용
# "미러 동기화는 GitHub Actions가 이미 잘 하고 있다"
# → 우리 코드에서 복잡한 브랜치 추적 로직을 제거

# KISS 적용
# "이 함수는 한 가지 일만 해야 한다"
def get_mirror_url(repo_name: str) -> str:
    return f"https://github.com/{repo_name}"
```

## 실전 적용

### 1. 불필요한 추상화 피하기

```python
# ❌ 과도한 추상화
class AbstractRepositoryFactory:
    def create_repository(self) -> AbstractRepository:
        pass

class GitHubRepositoryFactory(AbstractRepositoryFactory):
    def create_repository(self) -> GitHubRepository:
        return GitHubRepository()

class RepositoryManager:
    def __init__(self, factory: AbstractRepositoryFactory):
        self.factory = factory

# 실제 사용
factory = GitHubRepositoryFactory()
manager = RepositoryManager(factory)
repo = manager.factory.create_repository()

# ✅ 필요한 만큼만 추상화
class GitHubClient:
    def get_repository(self, name: str) -> dict:
        response = requests.get(f"https://api.github.com/repos/{name}")
        return response.json()

# 실제 사용
client = GitHubClient()
repo = client.get_repository("user/repo")
```

### 2. 예측 가능한 복잡성 vs 불필요한 복잡성

```python
# ❌ 불필요한 복잡성: "미래를 위한" 코드
class MirrorConfig:
    def __init__(self):
        self.providers = {
            "github": GitHubProvider(),
            "gitlab": GitLabProvider(),  # 아직 사용 안 함
            "bitbucket": BitbucketProvider(),  # 아직 사용 안 함
        }
        self.strategies = {
            "full": FullSyncStrategy(),
            "incremental": IncrementalSyncStrategy(),  # 아직 구현 안 됨
            "selective": SelectiveSyncStrategy(),  # 아직 구현 안 됨
        }

# ✅ 필요한 복잡성만
class MirrorConfig:
    def __init__(self, github_token: str):
        self.github = GitHubClient(github_token)

    def sync(self, repo_name: str):
        # 현재 필요한 기능만
        return self.github.sync_repository(repo_name)
```

### 3. 조건부 로직 단순화

```python
# ❌ 복잡한 조건문
def should_update_mirror(mirror):
    if mirror.get("type") == "private":
        if mirror.get("permissions", {}).get("admin"):
            if mirror.get("last_updated"):
                last_update = parse_date(mirror["last_updated"])
                if (datetime.now() - last_update).days > 7:
                    return True
                else:
                    return False
            else:
                return True
        else:
            return False
    else:
        return True

# ✅ 단순하고 명확한 로직
def should_update_mirror(mirror):
    # 공개 저장소는 항상 업데이트
    if mirror.get("type") != "private":
        return True

    # 프라이빗은 관리자 권한 필요
    if not mirror.get("permissions", {}).get("admin"):
        return False

    # 일주일 이상 지났거나 업데이트 기록이 없으면 업데이트
    last_updated = mirror.get("last_updated")
    if not last_updated:
        return True

    days_since_update = (datetime.now() - parse_date(last_updated)).days
    return days_since_update > 7
```

## 오캄의 면도날 적용 시 주의사항

### 1. 본질적 복잡성 vs 우발적 복잡성

```python
# 본질적 복잡성: 문제 자체가 복잡함
def calculate_tax(income, deductions, filing_status, state):
    """세금 계산은 본질적으로 복잡함"""
    # 복잡하지만 필요한 로직
    federal_tax = calculate_federal_tax(income, deductions, filing_status)
    state_tax = calculate_state_tax(income, state)
    fica_tax = calculate_fica_tax(income)

    return TaxCalculation(
        federal=federal_tax,
        state=state_tax,
        fica=fica_tax,
        total=federal_tax + state_tax + fica_tax
    )

# 우발적 복잡성: 구현이 불필요하게 복잡함
def get_user_name(user_id):
    """단순한 작업을 복잡하게 만듦"""
    user_factory = UserFactory()
    user_repository = user_factory.create_repository()
    user_service = UserService(user_repository)
    user_dto = user_service.get_user_by_id(user_id)
    user_entity = UserMapper.dto_to_entity(user_dto)
    return user_entity.get_display_name()
```

### 2. 때로는 명시적인 것이 더 단순함

```python
# ❌ 과도하게 축약된 코드
def p(d, o="json"):
    return json.dumps(d) if o == "j" else str(d)

# ✅ 명시적이고 이해하기 쉬운 코드
def format_data(data, output_format="json"):
    if output_format == "json":
        return json.dumps(data)
    else:
        return str(data)
```

### 3. 성능 vs 단순성

```python
# 단순하지만 비효율적
def find_duplicates_simple(items):
    duplicates = []
    for i in range(len(items)):
        for j in range(i + 1, len(items)):
            if items[i] == items[j] and items[i] not in duplicates:
                duplicates.append(items[i])
    return duplicates

# 복잡하지만 효율적 (필요한 복잡성)
def find_duplicates_efficient(items):
    seen = set()
    duplicates = set()
    for item in items:
        if item in seen:
            duplicates.add(item)
        else:
            seen.add(item)
    return list(duplicates)
```

## 실제 사례: cli-git 프로젝트

### 적용 전: 복잡한 브랜치 추적

```python
def sync_mirror_with_branch_tracking(repo_url, mirror_url, branch_config):
    """모든 브랜치를 추적하고 동기화하는 복잡한 로직"""
    # 1. 모든 원격 브랜치 가져오기
    remote_branches = get_all_remote_branches(repo_url)

    # 2. 로컬 추적 브랜치 생성
    for branch in remote_branches:
        create_tracking_branch(branch)

    # 3. 각 브랜치별 설정 적용
    for branch, config in branch_config.items():
        apply_branch_specific_config(branch, config)

    # 4. 브랜치별 동기화 규칙 적용
    sync_rules = load_sync_rules()
    for rule in sync_rules:
        apply_sync_rule(rule)

    # ... 더 많은 복잡한 로직
```

### 적용 후: GitHub Actions에 위임

```python
def setup_mirror_sync(repo_path: Path, upstream_url: str):
    """GitHub Actions가 동기화를 처리하도록 워크플로우만 설정"""
    workflow_content = f"""
name: Mirror Sync
on:
  schedule:
    - cron: '0 */6 * * *'
  workflow_dispatch:

jobs:
  mirror:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: |
          git remote add upstream {upstream_url}
          git fetch upstream
          git push --all origin
          git push --tags origin
"""

    workflow_path = repo_path / ".github/workflows/mirror-sync.yml"
    workflow_path.parent.mkdir(parents=True, exist_ok=True)
    workflow_path.write_text(workflow_content)
```

**결과:**
- 코드 라인 수: 200줄 → 20줄
- 버그 가능성: 대폭 감소
- 유지보수: GitHub Actions가 관리
- 테스트: 워크플로우 파일 생성만 확인하면 됨

## 아인슈타인의 지혜

> "Everything should be made as simple as possible, but not simpler" - Albert Einstein

이는 오캄의 면도날의 현대적 해석입니다:
- **가능한 한 단순하게**: 불필요한 복잡성 제거
- **하지만 지나치게 단순하지 않게**: 필요한 기능은 유지

## 실용적 가이드라인

1. **YAGNI (You Aren't Gonna Need It)**: 지금 필요하지 않은 것은 만들지 마라
2. **한 번에 하나씩**: 여러 문제를 동시에 해결하려 하지 마라
3. **명확성 우선**: 영리한 코드보다 명확한 코드
4. **지속적 단순화**: 리팩토링을 통한 지속적인 단순성 유지

```python
# 오캄의 면도날 체크리스트
def should_add_this_feature():
    questions = [
        "지금 당장 필요한가?",
        "더 간단한 해결책은 없는가?",
        "기존 도구로 해결할 수 있는가?",
        "이 복잡성이 실제 가치를 제공하는가?",
    ]

    # 모든 질문에 명확한 답이 있을 때만 추가
    return all(has_clear_answer(q) for q in questions)
```

## 결론

오캄의 면도날은 단순히 "적은 것이 좋다"가 아니라 "불필요한 것을 제거하라"는 원칙입니다. 소프트웨어 개발에서는:

1. 문제를 정확히 이해하고
2. 가장 직접적인 해결책을 찾고
3. 필요한 만큼만 구현하며
4. 지속적으로 단순성을 유지하는 것

이것이 오캄의 면도날을 실천하는 방법입니다.
