# 테스트 주도 리팩토링

## 개요

테스트 주도 개발(TDD)의 핵심은 "Red-Green-Refactor" 사이클입니다. 하지만 기존 코드를 리팩토링할 때는 이미 작성된 테스트가 우리의 가이드가 됩니다. 이 문서는 테스트를 활용한 안전한 리팩토링 방법을 다룹니다.

## 핵심 원칙

### 1. 테스트는 명세서다

테스트는 코드가 "어떻게" 동작하는지가 아닌 "무엇을" 해야 하는지를 명시합니다:

```python
def test_mirror_update_requires_admin_access():
    """프라이빗 저장소는 관리자 권한이 필요함을 명시"""
    repo_data = {
        "private": True,
        "permissions": {"admin": False}
    }

    result = can_update_mirror(repo_data)

    assert result == (False, "No admin access to private repository")
```

이 테스트는 비즈니스 규칙을 문서화합니다.

### 2. 행동 중심 테스트 vs 구현 중심 테스트

```python
# ❌ 구현 중심 테스트
def test_update_calls_git_command():
    """구현 세부사항에 의존"""
    with patch("subprocess.run") as mock_run:
        update_mirror("user/repo")

        # Git 명령어가 정확히 이렇게 호출되었는지 확인
        mock_run.assert_called_with(
            ["git", "clone", "--mirror", "https://github.com/user/repo.git"]
        )

# ✅ 행동 중심 테스트
def test_update_creates_mirror_repository():
    """의도된 결과에 집중"""
    # Given
    repo_url = "https://github.com/user/repo.git"

    # When
    result = update_mirror(repo_url)

    # Then
    assert result.success == True
    assert result.mirror_exists == True
```

## Red-Green-Refactor 사이클

### 1. Red (실패하는 테스트)

```python
def test_calculate_mirror_statistics():
    """아직 구현되지 않은 기능"""
    mirrors = [
        {"name": "repo1", "size": 100, "updated": "2024-01-01"},
        {"name": "repo2", "size": 200, "updated": "2024-01-02"},
    ]

    stats = calculate_mirror_statistics(mirrors)

    assert stats["total_count"] == 2
    assert stats["total_size"] == 300
    assert stats["last_updated"] == "2024-01-02"
```

### 2. Green (최소한의 구현)

```python
def calculate_mirror_statistics(mirrors):
    """테스트를 통과하는 최소 구현"""
    return {
        "total_count": len(mirrors),
        "total_size": sum(m["size"] for m in mirrors),
        "last_updated": max(m["updated"] for m in mirrors) if mirrors else None
    }
```

### 3. Refactor (개선)

```python
from typing import List, Dict, Optional
from datetime import datetime

def calculate_mirror_statistics(mirrors: List[Dict]) -> Dict:
    """타입 힌트와 검증 추가"""
    if not mirrors:
        return {
            "total_count": 0,
            "total_size": 0,
            "last_updated": None
        }

    # 더 나은 변수명과 명확한 로직
    total_size_bytes = sum(mirror.get("size", 0) for mirror in mirrors)
    update_dates = [m["updated"] for m in mirrors if "updated" in m]

    return {
        "total_count": len(mirrors),
        "total_size": total_size_bytes,
        "last_updated": max(update_dates) if update_dates else None
    }
```

## 기존 코드 리팩토링 전략

### 1. 특성화 테스트 (Characterization Tests)

기존 동작을 문서화하는 테스트를 먼저 작성:

```python
# 리팩토링 전에 현재 동작 캡처
def test_existing_scan_behavior():
    """현재 scan 함수의 동작을 정확히 기록"""
    with patch("typer.echo") as mock_echo:
        # 실제 함수 호출
        result = scan_mirrors(verbose=True)

        # 현재 동작 기록
        assert mock_echo.call_count == 5  # 정확한 출력 횟수
        assert "Scanning" in mock_echo.call_args_list[0][0][0]
        # ... 모든 동작 캡처
```

### 2. 안전한 추출 (Safe Extract)

```python
# Before: 긴 함수
def process_mirrors(mirrors, config):
    """100줄의 복잡한 함수"""
    results = []

    # 섹션 1: 유효성 검증 (20줄)
    for mirror in mirrors:
        if not mirror.get("url"):
            continue
        # ... 더 많은 검증

    # 섹션 2: 데이터 변환 (30줄)
    for mirror in mirrors:
        transformed = {
            "name": mirror["name"],
            # ... 복잡한 변환 로직
        }

    # 섹션 3: 결과 처리 (50줄)
    # ...

    return results

# Step 1: 테스트로 현재 동작 보호
def test_process_mirrors_current_behavior():
    # 모든 엣지 케이스 포함
    pass

# Step 2: 하나씩 추출
def validate_mirrors(mirrors):
    """추출된 검증 로직"""
    valid_mirrors = []
    for mirror in mirrors:
        if mirror.get("url"):
            valid_mirrors.append(mirror)
    return valid_mirrors

# Step 3: 원본 함수에서 사용
def process_mirrors(mirrors, config):
    valid_mirrors = validate_mirrors(mirrors)  # 추출된 함수 사용
    # ... 나머지 로직
```

### 3. 병렬 변경 (Parallel Change)

기존 코드와 새 코드를 일시적으로 공존:

```python
# Step 1: 새로운 구현 추가
def process_mirrors_v2(mirrors, config):
    """새로운 구현"""
    pass

# Step 2: 기존 함수에서 새 구현 호출
def process_mirrors(mirrors, config):
    """기존 인터페이스 유지"""
    # 일시적으로 두 구현 실행하여 비교
    old_result = _process_mirrors_old(mirrors, config)
    new_result = process_mirrors_v2(mirrors, config)

    # 개발 중에는 결과 비교
    assert old_result == new_result, "새 구현이 다른 결과 생성"

    return new_result

# Step 3: 모든 테스트 통과 후 old 구현 제거
```

## 테스트 커버리지와 품질

### 1. 의미 있는 커버리지

```python
# ❌ 커버리지만을 위한 테스트
def test_init():
    """의미 없는 테스트"""
    obj = MyClass()
    assert obj is not None

# ✅ 행동을 검증하는 테스트
def test_mirror_config_defaults():
    """기본값 동작 검증"""
    config = MirrorConfig()

    assert config.retry_count == 3
    assert config.timeout == 30
    assert config.use_ssh == False
```

### 2. 엣지 케이스 중심

```python
def test_empty_mirror_list():
    """빈 리스트 처리"""
    result = process_mirrors([])
    assert result == {"count": 0, "errors": []}

def test_malformed_mirror_data():
    """잘못된 데이터 처리"""
    mirrors = [{"name": "test"}]  # URL 누락
    result = process_mirrors(mirrors)
    assert len(result["errors"]) == 1

def test_concurrent_updates():
    """동시성 시나리오"""
    # 동시에 여러 미러 업데이트
    pass
```

## 리팩토링 중 테스트 전략

### 1. 테스트 신호등

```python
# 🟢 Green: 모든 테스트 통과
$ pytest tests/
=================== 150 passed in 2.34s ===================

# 🟡 Yellow: 리팩토링 중 (테스트는 여전히 통과해야 함)
# 코드 구조 변경 중...
$ pytest tests/
=================== 150 passed in 2.34s ===================

# 🔴 Red: 즉시 중단!
$ pytest tests/
=================== 1 failed, 149 passed ===================
# 무언가 잘못됨 - 변경사항 되돌리기
```

### 2. 점진적 리팩토링 체크포인트

```python
def refactor_large_module():
    """대규모 리팩토링 절차"""

    # Checkpoint 1: 특성화 테스트 추가
    run_tests()  # ✅ 통과
    git_commit("Add characterization tests")

    # Checkpoint 2: 첫 번째 함수 추출
    extract_validation_logic()
    run_tests()  # ✅ 통과
    git_commit("Extract validation logic")

    # Checkpoint 3: 두 번째 함수 추출
    extract_transformation_logic()
    run_tests()  # ❌ 실패!
    git_revert()  # 즉시 되돌리기

    # 실패 원인 분석 후 재시도...
```

### 3. 테스트 더블 활용

```python
# 외부 의존성 격리
class TestMirrorUpdate:
    @patch("cli_git.utils.github_api.get_repo")
    @patch("cli_git.utils.git.clone_repo")
    def test_update_with_mocked_dependencies(self, mock_clone, mock_get):
        """외부 의존성 없이 핵심 로직 테스트"""
        mock_get.return_value = {"name": "test", "clone_url": "..."}
        mock_clone.return_value = True

        result = update_mirror("user/repo")

        assert result.success == True
```

## 실전 예시: 테스트 주도 리팩토링

### Before: 테스트하기 어려운 코드

```python
def sync_all_mirrors():
    """모든 것이 뒤엉킨 함수"""
    print("Starting mirror sync...")

    # 설정 로드 (I/O)
    with open("config.json") as f:
        config = json.load(f)

    # API 호출 (I/O)
    response = requests.get(f"{config['api_url']}/mirrors")
    mirrors = response.json()

    # 처리 로직
    for mirror in mirrors:
        try:
            # 더 많은 I/O...
            subprocess.run(["git", "pull", mirror["url"]])
            print(f"✓ {mirror['name']}")
        except:
            print(f"✗ {mirror['name']}")
```

### Step 1: 현재 동작 테스트

```python
@patch("builtins.open")
@patch("requests.get")
@patch("subprocess.run")
@patch("builtins.print")
def test_sync_all_mirrors_current_behavior(
    mock_print, mock_run, mock_get, mock_open
):
    """현재 동작을 정확히 캡처"""
    # 설정
    mock_open.return_value.__enter__.return_value.read.return_value = '{"api_url": "http://api"}'
    mock_get.return_value.json.return_value = [{"name": "repo1", "url": "url1"}]

    # 실행
    sync_all_mirrors()

    # 검증
    assert mock_print.call_count == 2
    mock_run.assert_called_once()
```

### Step 2: 점진적 분리

```python
# 순수 함수 추출
def process_mirror_results(results: List[Tuple[str, bool]]) -> Dict:
    """결과 처리 로직 (순수 함수)"""
    successful = [name for name, success in results if success]
    failed = [name for name, success in results if not success]

    return {
        "successful": successful,
        "failed": failed,
        "summary": f"✓ {len(successful)}, ✗ {len(failed)}"
    }

# 테스트 가능한 새 구조
def sync_all_mirrors(config_path="config.json"):
    """리팩토링된 버전"""
    # 의존성 주입
    config = load_config(config_path)
    mirrors = fetch_mirrors(config["api_url"])

    # 핵심 로직 (테스트 가능)
    results = []
    for mirror in mirrors:
        success = sync_single_mirror(mirror)
        results.append((mirror["name"], success))

    # 순수 함수 사용
    summary = process_mirror_results(results)

    # I/O
    display_results(summary)

    return summary  # 테스트 가능한 반환값
```

## 교훈과 모범 사례

1. **테스트 없이 리팩토링하지 마라**: 안전망 없이 줄타기하는 것과 같다
2. **작은 단계로 진행하라**: 각 변경 후 테스트 실행
3. **커밋을 자주 하라**: 각 성공적인 리팩토링 단계마다
4. **테스트도 리팩토링하라**: 중복 제거, 가독성 개선
5. **테스트가 실패하면 즉시 중단하라**: 원인 파악이 우선

> "리팩토링의 정의에는 '겉보기 동작은 그대로 유지한다'는 말이 들어있다" - Martin Fowler

테스트는 이 "겉보기 동작"을 지키는 파수꾼입니다.
